# Research: Подключение фронтенда к API дилемм

**Feature**: `001-connect-backend`  
**Date**: 2026-01-21  
**Goal**: Определить технические решения для интеграции `frontend-dilemma` с задеплоенным `backend-dilemma` без изменения доменной логики.

---

## 1. Базовый URL и конфигурация API

- **Unknown / Question**: Как фронтенд должен конфигурировать базовый URL для backend‑API (dev/prod, Railway)?  
- **Decision**: Использовать централизованный модуль конфигурации в `frontend-dilemma` (`shared/lib/api.ts` или аналог), который читает base URL из переменных окружения Vite (например, `VITE_API_BASE_URL`) с дефолтом на продакшен‑URL для деплоя.  
- **Rationale**: Это вписывается в типичный Vite‑подход, позволяет легко переключать окружения и не хардкодить Railway‑URL в коде.  
- **Alternatives considered**:
  - Жёстко прописать URL Railway в коде — отвергнуто, т.к. усложняет локальную разработку и деплой в другие среды.
  - Динамически строить URL от `window.location` — не подходит, так как backend и фронтенд могут находиться на разных доменах.

---

## 2. Стратегия хранения идентификатора пользователя

- **Unknown / Question**: Как хранить и переиспользовать UUID пользователя на фронте?  
- **Decision**: Генерировать UUID на фронтенде при первом заходе пользователя (если нет сохранённого), сохранять его в `localStorage` и отправлять в каждом запросе в HTTP‑заголовке `X-User-UUID` (в соответствии с backend‑спецификацией).  
- **Rationale**: Соответствует существующей доменной модели, даёт стабильный идентификатор между сессиями и устройствами при копировании ссылки, не требует полноценной аутентификации.  
- **Alternatives considered**:
  - Куки — потенциальные сложности с CORS и доменами, не дают дополнительной ценности по сравнению с `localStorage`.
  - Генерация UUID на backend и возврат в ответе — потребовало бы изменения backend‑логики, что выходит за рамки фичи.

---

## 3. Обёртка над HTTP‑клиентом и обработка ошибок

- **Unknown / Question**: Как централизовать вызовы API и обработку ошибок?  
- **Decision**: Использовать единый helper в `shared/lib/api.ts` (или аналогичный модуль) поверх `fetch`, который:
  - добавляет базовый URL ко всем путям;
  - прокидывает `X-User-UUID` в заголовки;
  - нормализует структуру ошибок (сетевые, 4xx/5xx) и возвращает их в одном формате для UI.  
- **Rationale**: Централизованный слой упрощает поддержку, позволяет в одном месте менять стратегию работы с API и логику ретраев/логирования.  
- **Alternatives considered**:
  - Прямое использование `fetch` в компонентах — ведёт к дублированию кода и разным форматам обработки ошибок.
  - Подключение стороннего клиента (axios, react-query) — добавляет зависимости и усложняет проект, без явной необходимости в рамках текущей фичи.

---

## 4. Соответствие существующему OpenAPI‑контракту

- **Unknown / Question**: Нужно ли создавать новый контракт для фронтенда или использовать уже существующий `api-spec.json`?  
- **Decision**: Использовать существующий OpenAPI‑контракт из `specs/001-dilemma-system/contracts/api-spec.json` как единственный источник правды и в новой фиче только выделить подмножество используемых эндпоинтов.  
- **Rationale**: Избегаем дублирования контрактов и риска рассинхронизации, опираемся на уже согласованный и протестированный бэкенд.  
- **Alternatives considered**:
  - Создать отдельный OpenAPI только под фронтенд — лишнее дублирование с высокой вероятностью расхождений.
  - Документировать контракты только в виде markdown — ухудшает точность и не даёт формального описания схем.

---

## 5. Обновление фронтенд‑состояния и согласованность с сервером

- **Unknown / Question**: Как избежать рассинхронизации состояния дилем и решений между фронтом и backend‑API?  
- **Decision**: После успешных мутаций (initial/final choice) фронтенд:
  - либо повторно запрашивает актуальные данные по дилеме/истории с сервера;
  - либо использует ответ сервера как источник истины и обновляет локальное состояние строго по нему.  
- **Rationale**: Это гарантирует, что UI всегда отражает то, что сохранено на сервере, и минимизирует риск "расходящихся" состояний.  
- **Alternatives considered**:
  - Оптимистичные апдейты без последующей синхронизации — повышенный риск расхождений при ошибках сетей/серверов.
  - Полная перезагрузка страницы — ухудшение UX, нет необходимости при наличии SPA‑архитектуры.

---

## 6. Обработка ошибок и UX‑поведение

- **Unknown / Question**: Какое поведение фронта при временных ошибках API и сетевых проблемах?  
- **Decision**: Для каждой ключевой операции (загрузка списка дилем, initial choice, final choice, загрузка статистики) предусмотреть:
  - отображение явного сообщения об ошибке (в i18n‑слоях);
  - возможность повторить запрос без перезагрузки приложения;
  - логирование технических деталей ошибки в консоль (для дебага), но не в UI.  
- **Rationale**: Выполняет требования спеки по устойчивости и не перегружает пользователя техническими деталями.  
- **Alternatives considered**:
  - Молчаливое игнорирование ошибок — приводит к "зависшему" UI и непониманию у пользователя.
  - Автоматические бесконечные ретраи — могут ухудшить нагрузку на сервер и UX.

---

## 7. Вывод по Phase 0

Все ключевые технические вопросы по интеграции фронтенда с backend‑API (base URL, UUID, слой API, согласованность состояния, работа с существующим OpenAPI, обработка ошибок) имеют зафиксированные решения. Дополнительных `NEEDS CLARIFICATION` для перехода к проектированию (Phase 1) не требуется.

